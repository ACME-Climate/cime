#!/usr/bin/env perl
#-----------------------------------------------------------------------------------------------
#
# xmlchange
#
# This utility allows the user to change a env_*xml file via a commandline interface.
#
# The command is echoed to the CaseStatus file, unless -noecho is given. The
# purpose of this echoing is to provide a "paper trail" of changes made by the
# user, so calls to xmlchange by cesm scripts that are part of the normal case
# setup/build process should generally use -noecho.
#
#-----------------------------------------------------------------------------------------------

use strict;
#use warnings;
#use diagnostics;
use Cwd qw( getcwd abs_path chdir);
use English;
use Getopt::Long;
use IO::File;
use IO::Handle;
use File::Copy;

#-----------------------------------------------------------------------------------------------
sub usage {
    die <<EOF;
SYNOPSIS
     xmlchange [options] <listofsettings>
DESCRIPTION
     allows user to modify an xml file and perform consistency checks where appropriate

OPTIONS
     User supplied values are denoted in angle brackets (<>).  Any value that contains
     white-space must be quoted.  Long option names may be supplied with either single
     or double leading dashes.  A consequence of this is that single letter options may
     NOT be bundled.
REQUIRED OPTIONS

   Either provide ALL of the following options to modify a single variable...

     -file <name>         xml file to modify 
                          NOTE: this is no longer utilized - but is there for backwards compatibility
     -id <name>           xml variable id
     -val <name> 	  xml new value for variable id

   Or provide the settings in a comma-delimited list form as: <listofsettings>

      var=value,var2=value2

   To set one or more variables without having to know the filename a variable is in.

   NOTE: NO-Whitespace. No spaces between commas, or in values unless you quote the
         entire string so the shell recognizes it as one thing. Also values can NOT
         contain the symbols "=" or ",".

OPTIONAL
     -append [or -a]      append value to the end of existing value
     -help [or -h]        Print usage to STDOUT.
     -noecho              Do NOT echo command to CaseStatus file
     -silent [or -s]      Turns on silent mode - only fatal messages issued.
     -verbose [or -v]     Turn on verbose echoing of settings.
     -warn [or -w]        Warn and abort if you are overwriting data that is not blank

NOTE:
     You can NOT use both the warn and append modes at the same time.
EOF
}

#-----------------------------------------------------------------------------------------------
if ($#ARGV == -1) {
    print "ERROR: no arguments sent in\n";
    usage();
}

# Setting autoflush (an IO::Handle method) on STDOUT helps in debugging.  It forces the test
# descriptions to be printed to STDOUT before the error messages start.
*STDOUT->autoflush();                  

my $cwd = getcwd();   # current working directory
unshift @INC, "$cwd/Tools";
require ConfigCase;

# Parse command-line options.
my @saved_argv = @ARGV;

my %opts = (
    file=>undef,
    id=>undef,
    val=>undef,
    );

GetOptions(
    "a|append"   => \$opts{'append'},
    "file=s"     => \$opts{'file'},
    "id=s"       => \$opts{'id'},
    "val=s"      => \$opts{'val'},
    "h|help"     => \$opts{'help'},
    "noecho"     => \$opts{'noecho'},
    "s|silent"   => \$opts{'silent'},
    "v|verbose"  => \$opts{'verbose'},
    "w|warn"     => \$opts{'warn'},
)  or usage();

# Give usage message.
usage() if $opts{'help'};

# Get the list form if anything else is set
my $settinglist = shift(@ARGV);

# Check for unparsed argumentss
if (@ARGV) {
    print "ERROR: unrecognized arguments: @ARGV\n";
    print "A list of ID's needs to be comma-delimited with NO-WHITESPACE!\n";
    usage();
}

# Check for manditory case input if not just listing valid values
my %idlist;
if ( ! defined($settinglist) ) {
   foreach my $item ( "file", "id", "val" ) {
      if ( ! defined($opts{$item}) ) {
         print "ERROR: Must provide $item as input argument \n";
         usage();
      }
   }
   $idlist{$opts{'id'}} = $opts{'val'};
} else {
   foreach my $varval ( split( /,/, $settinglist ) ) {
      if ( $varval =~ /^([a-zA-Z0-9_]+)=([^,=]+)$/ ) {
         if ( defined($idlist{$1}) ) {
            print "ERROR: variable $1 was already set once in the settings list: $settinglist\n";
         }
         $idlist{$1} = $2;
      } else {
         print "ERROR: variable = value setting is NOT recognized: $varval\n";
         die "Should be of the form: variable = value\n";
      }
   }
}

# If filename is input as option - check that it is supported
my @filenames = qw(env_run.xml env_build.xml env_case.xml env_mach_pes.xml);
if ( ! defined($settinglist) ) {
   push(@filenames, $opts{'file'});
   my $status = 0;
   foreach my $filename (@filenames) {
       if ($opts{'file'} eq $filename) {
	   $status = 1;
	   last;
       }
   }
   if ($status != 1) {
       print "** $opts{'file'} is not an acceptable file to modify *** \n";
       print "*** acceptable files are @filenames *** \n";
       print "*** Note: env_archive.xml can be modified manually and checked with xmllint. *** \n";
       print " *** See st_archive --help for details *** \n";
       die;
   }
}

# Define 3 print levels:
# 0 - only issue fatal error messages
# 1 - only informs what files are created (default)
# 2 - verbose
my $print = 1;
if ($opts{'silent'})  { $print = 0; }
if ($opts{'verbose'}) { $print = 2; }
if ($opts{'append'} && $opts{'warn'} ) {
    die "warn and append modes can NOT both be set\n";
}
my $eol = "\n";

#-----------------------------------------------------------------------------------------------
my $parser = XML::LibXML->new( no_blanks => 1);


my @files = ("env_run.xml", "env_build.xml", "env_case.xml", "env_mach_pes.xml");

# Determine the env_xxx.xml file for each required xmlchange variable
# store these in the hash %id_file
my %id_file;
foreach my $id ( keys(%idlist) ) {
    foreach my $file (@files) {
	my $xml_file = $parser->parse_file($file); 
	my @nodes = ($xml_file->findnodes(".//entry[\@id=\"$id\"]"));
	if (@nodes) {
	    $id_file{$id} = $file;

	    # Now do error checking for requested change
	    my $node  = $nodes[0];
	    my $type  = $node->getAttribute('type');
	    my $value = $node->getAttribute('value');
	    my $is_list_value = $node->getAttribute('list');
	    my $valid_values  = $node->getAttribute('valid_values');

	    # Determine if requested change is a value
	    # Will die in is_valid_values if the check fails
	    ConfigCase::is_valid_value($idlist{$id}, $value, $valid_values, $is_list_value);

	    # If append mode is on - check that variable is of the character type
	    if ($opts{'append'}) {
		if ( $type ne 'char') {
		    die "ERROR xmlchange: Append mode can ONLY work on character type values.\n";
		}
	    }

	    # If warn mode is on, abort if data is set to something other than missing values
	    if ($opts{'warn'}) {
		if ( $type ne 'char') {
		    if ( ($value !~ m/^\s*$/) && ($value !~ m/UNSET/i) ) { 
			die "ERROR xmlchange: Variable $id is already set to $value.\n";
		    }
		} elsif ( $value != -99 && $value != -999 && $value != -999.99 ) { 
		    die "ERROR xmlchange : Variable $id is already set to $value.\n";
		}
	    }
	    last;
	}
    }
    if (! $id_file{$id}) {
	die "ERROR xmlchange: variable $id is not a valid name \n";
    }
}

foreach my $file (values (%id_file)) {
    # Before overwriting the file, make a backup copy in case 
    # there are file system problems, this way the original xml file does not get corrupted.
    my $backupfile = "$file.bak";
    copy($file, $backupfile) or die "A problem occurred copying $file to $backupfile, reason was $!";
    
    # Now determine new xml values and overwrite xml file
    my $xml = $parser->parse_file($file); 

    # Determine the header
    my @nodes_header = $xml->findnodes(".//header");
    my $header_text = $nodes_header[0]->textContent();

    # Write out the header
    my $fh = IO::File->new($file, '>' ) or die "can't open file: $file\n";
    print $fh "<?xml version=\"1.0\"?> \n";
    print $fh "\n";
    print $fh "<config_definition> \n";
    print $fh "\n";
    print $fh "<header>";
    print $fh "$header_text \n";
    print $fh "</header> ";

    # Loop over each variable and write it out
    foreach my $node ($xml->findnodes(".//entry")) {
	# Determine all of the attributes of the variable node
	my $name         = $node->getAttribute('id');
	my $valid_values = $node->getAttribute('valid_values');
	my $type         = $node->getAttribute('type');
	my $desc         = $node->getAttribute('desc');
	my $list         = $node->getAttribute('list');
	my $value        = $node->getAttribute('value');

	# Make a change to the variable's value if apropriate
	foreach my $id ( keys(%idlist) ) {
	    if ($id eq $name) {
		my $id_value = $idlist{$id};
		my $newval   = $id_value;
		if ($opts{'append'}) {
		    # Append new value on the end of old only if old NOT unset
		    if ( ($value !~ m/^\s*$/) && ($value !~ m/UNSET/i) ) { 
			$newval = "$value $id_value";
		    }
		}		    
		$newval =~ s/'/&apos;/g;
		$newval =~ s/\</&lt;/g;
		$newval =~ s/\</&gt;/g;
		$value  = $newval;
		last;
	    }
	} 

	# Write the variable out - either the original or the modified
	print $fh "\n";
	print $fh "<entry id=\"$name\"  value=\"$value\"\n";   	    
	print $fh "   type=\"$type\"\n"; 
	print $fh "   desc=\"$desc\"\n";
	if ($valid_values ne '') {print $fh "   valid_values=\"$valid_values\"\n";}
	if ($list         ne '') {print $fh "   list=\"$list\"\n";}
	print $fh "/> \n";
    }

    # print out the tail
    print $fh "\n";
    print $fh "</config_definition> \n";

    # Before finishing, remove the backup files.  
    unlink($backupfile) or warn "unable to link $backupfile, $!";
}

if (! $opts{'noecho'}) {
   echo_command_to_CaseStatus();
}

if ($print>=2) { print "xmlchange done.\n"; }
exit;

#-----------------------------------------------------------------------------------------------
sub echo_command_to_CaseStatus {
   # Echoes this xmlchange command to the CaseStatus file

    my $cwd = getcwd();                    # current working directory

   if (-f "./CaseStatus") {
      open my $CS, ">>", "$cwd/CaseStatus";
      print $CS "<command>xmlchange @saved_argv</command>\n";
      close $CS;
   }
   else {
      warn "WARNING: No CaseStatus file found; this xmlchange command has been executed, but not recorded in the CaseStatus file\n";
   }
}   



