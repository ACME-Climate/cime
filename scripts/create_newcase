#!/usr/bin/env perl 
#-----------------------------------------------------------------------------------------------
#
# create_newcase
#
# This utility allows the users to specify configuration
# options via a commandline interface.
#
#-----------------------------------------------------------------------------------------------

use strict;
use Cwd;
use English;
use Getopt::Long;
use Cwd qw( getcwd abs_path chdir);
use IO::File;
use IO::Handle;
use Data::Dumper;
use File::Basename;
use File::Path qw(mkpath);

# Check for the existence of XML::LibXML in whatever perl distribution happens to be in use.  
# If not found, print a warning message then exit. 
eval {
    require XML::LibXML;
    XML::LibXML->import();
};
if($@)
{
    my $warning = <<END;
WARNING:
    The perl module XML::LibXML is needed for XML parsing in the CESM script system.  
	Please contact your local systems administrators or IT staff and have them install it for 
	you, or install the module locally.  

END
	print "$warning\n";
    exit(1);
}

#-----------------------------------------------------------------------------------------------
# Setting autoflush (an IO::Handle method) on STDOUT helps in debugging.  It forces the test
# descriptions to be printed to STDOUT before the error messages start.
*STDOUT->autoflush();                  

#-----------------------------------------------------------------------------------------------
# Set the directory that contains the CESM configuration scripts.  If the create_newcase command was
# issued using a relative or absolute path, that path is in $ProgDir.  Otherwise assume the
# command was issued from the current working directory.

(my $ProgName = $0) =~ s!(.*)/!!;      # name of this script
my $ProgDir = $1;                      # name of directory containing this script -- may be a
                                       # relative or absolute path, or null if the script is in
                                       # the user's PATH
my $cwd = getcwd();                    # current working directory
my $cfgdir;                            # absolute pathname of directory that contains this script
if ($ProgDir) { 
    $cfgdir = abs_path($ProgDir);
} else {
    $cfgdir = $cwd;
}

my $cimeroot = abs_path("$cfgdir/../");
(-d "$cimeroot")  or  die <<"EOF";
** Cannot find cimeroot directory \"$cimeroot\" **
EOF

#-----------------------------------------------------------------------------------------------
if ($#ARGV == -1) {
    usage();
}
#-----------------------------------------------------------------------------------------------

sub usage {
    die <<EOF;

SYNOPSIS
  create_newcase [options]

OPTIONS
  User supplied values are denoted in angle brackets (<>).  Any value that contains
  white-space must be quoted.  Long option names may be supplied with either single
  or double leading dashes.  A consequence of this is that single letter options may
  NOT be bundled.

  -case <name>             Specifies the case name (required).
  -compset <name>          Specify a CESM compset (required).
  -res <name>              Specify a CESM grid resolution (required).
  -mach <name>             Specify a CESM machine (required).
  -pes_file <name>         Full pathname of pes file to use (will overwrite default settings) (optional)
  -project <name>          Specify a project id for the case (optional)
                           default: user-specified environment variable PROJECT or ACCOUNT
                                    or read from ~/.cesm_proj or ~/.ccsm_proj
  -compiler <name>         Specify a compiler for the target machine (optional)
                           default: default compiler for the target machine
  -mpilib <name>           Specify a mpi library for the target machine (optional)
                           default: default mpi library for the target machine
                           allowed: openmpi, mpich, ibm, mpi-serial, etc
                                    redundant with _M confopts setting
  -mach_dir <path>         Specify the locations of the Machines directory (optional).
                           default: \$cimeroot/machines
  -user_mods_dir <path>    Path to directory with user_nl_* files and xmlchange
                           commands to utilize (optional). For non-test cases, this 
                           can also include SourceMods
  -confopts <value>        Specify some additional configuration options (optional) as follows:
                           _AOA  = aoflux on atm grid
                           _AOE  = aoflux on exch grid
                           _CG   = gregorian calendar
                           _D    = debug
                           _E    = esmf interfaces
                           _IOP* = PnetCDF IO test where * is  A(atm), C(cpl), G(glc), 
                                   I(ice), L(lnd), O(ocn), W(wav) or blank (all components)
                           _L*   = set run length y, m, d, h, s, n(nsteps) plus integer 
                                   (ie _Lm6 for 6 months) 
                           _M*   = set the mpilib where * is default, mpi-serial, mpich, etc
                           _N*   = set NINST_ env value to * where * is an integer
                           _P*   = set pecount to specific values include 
                                   T,S,M,L,X,1,1x1,16,16x1,4x4,16x1D, etc
  -petype  <name>          Valid values are [threaded | mpionly] 
                           Force pes to be all threaded or all mpi
			   default: this is not set
  -pecount <name>          Value of S,M,L,X1,X2 (optional). 
                           default: M, partially redundant with confopts _P
  -user_compset <name>     Long name for new user compset to use (optional)
                           This assumes that all of the compset settings in the 
                           long name have been defined in cimeconfig/compsets.xml
  -user_grid_file <name>   Full pathname of grid file to use (optional)
                           This should be a "copy" of cimeconfig/grids.xml
                           with the new user grid changes added to it
  -help [or -h]            Print usage to STDOUT (optional).
  -testlist                List valid values for tests [normally only invoked by create_test] (optional).
  -silent [or -s]          Turns on silent mode - only fatal messages issued (optional).
  -verbose [or -v]         Turn on verbose echoing of settings made by create_newcase (optional).
  -xmlmode <name>          Sets format of xml files; normal or expert (optional). (default is normal) 
  -nowarning               Turns off checking of the known_problems repository. (default is on)
  -sharedlibroot           Used for re-using build components when building multiple CESM cases, 
                           default is \$EXEROOT

EXAMPLES

  #  ./create_newcase -case mycase1 -res f19_g16 -compset B1850CN -mach yellowstone
  #  ./create_newcase -case mycase2 -res f19_g16 -compset B1850CN -mach yellowstone -confopts _D_P16
  #  ./create_newcase -case mycase5 -res f19_g16 -compset B1850CN -mach yellowstone -confopts _CG_E -pes_file mypes_file

EOF
}

#-----------------------------------------------------------------------------------------------
# Save commandline
my $commandline = "create_newcase @ARGV";

#-----------------------------------------------------------------------------------------------
# Parse command-line options.
my %opts = (
    mach_dir => "$cimeroot/machines",
    user_mods_dir => undef,
    );
GetOptions(
    "case=s"                    => \$opts{'case'},
    "compset=s"                 => \$opts{'compset'},
    "confopts=s"                => \$opts{'confopts'},
    "project=s"                 => \$opts{'project'},  
    "compiler=s"                => \$opts{'compiler'},  
    "mpilib=s"                  => \$opts{'mpilib'},  
    "res=s"                     => \$opts{'res'},
    "h|help"                    => \$opts{'help'},
    "mach=s"                    => \$opts{'mach'},
    "mach_dir=s"                => \$opts{'mach_dir'},
    "user_mods_dir=s"           => \$opts{'user_mods_dir'},
    "pecount=s"                 => \$opts{'pecount'},
    "petype=s"                  => \$opts{'petype'},
    "pes_file=s"                => \$opts{'pes_file'}, 
    "user_grid_file=s"          => \$opts{'user_grid_file'},
    "s|silent"                  => \$opts{'silent'},
    "testname=s"                => \$opts{'testname'},
    "testlist"                  => \$opts{'testlist'},
    "v|verbose"                 => \$opts{'verbose'},
    "xmlmode=s"                 => \$opts{'xmlmode'},
    "nowarning"                 => \$opts{'nowarning'},
    "user_compset=s"            => \$opts{'user_compset'},
    "sharedlibroot=s"           => \$opts{'sharedlibroot'},
    )  or usage();

# Give usage message.
usage() if $opts{'help'};

# Check for unparsed argumentss
if (@ARGV) {
    print "ERROR: unrecognized arguments: @ARGV\n";
    usage();
}

#-----------------------------------------------------------------------------------------------
# Add $cfgdir/perl5lib to the list of paths that Perl searches for modules
my @dirs = ("$cfgdir", "$cimeroot/scripts/Tools", "$cimeroot/utils/perl5lib");
unshift @INC, @dirs;
require ConfigCase;
require ConfigCompsetGrid;
require ConfigPes;
require ConfigMachine;
require ConfigTests;
require ConfigCESM;
require ProjectTools;
require UserModsTools;
require Testing::TestLists; 

# Global variables
my $case;
my $caseroot; # set in _check_input_options
my $compset;  # set in _check_input_options
my $grid;     # set in _check_input_options
my $compiler; # set in _check_input_options
my $confopts; # set in _set_confopts 
my $machine;
my $testname;
my $pecount;
my $petype;
my $xmlmode;
my $project;
my $mpilib;
my $header_file;
my $sysmod;

# Define 3 print levels:
# 0 - only issue fatal error messages
# 1 - only informs what files are created (default)
# 2 - verbose
my $print = 1;
if ($opts{'silent'})  { $print = 0; }
if ($opts{'verbose'}) { $print = 2; }

if ($print>=2) { print "Setting configuration directory to $cfgdir\n"; }

#------------------------------------------------------------------------------------------
# Check input
#------------------------------------------------------------------------------------------
# Note that check_input_options will use the global hash opts
_check_input_options (\%opts);

#------------------------------------------------------------------------------------------
# Determine user_mods_dir
#------------------------------------------------------------------------------------------
my $user_mods_dir = $opts{'user_mods_dir'};
if ($user_mods_dir) {
    (-d "$user_mods_dir") or  die "** Cannot find user_mods_dir directory $user_mods_dir **"
}

#------------------------------------------------------------------------------------------
# *** Create empty new config object ***
#------------------------------------------------------------------------------------------
my $cfg_ref = ConfigCase->new("");

#------------------------------------------------------------------------------------------
# set the project specific file that will set up all the relevant directories that must 
# examined 
#------------------------------------------------------------------------------------------
my $definitions_file = "$cimeroot/scripts/cimeconfig/definitions_files.xml";
$cfg_ref->add_config_variables($definitions_file);

my $xml = XML::LibXML->new( no_blanks => 1)->parse_file($definitions_file);
my @nodes = $xml->findnodes(".//entry[\@id[contains(.,\"DEFINITIONS\")]]/default_value");
foreach my $node (@nodes) {
    my $file = $node->textContent();
    $file =~ s/\$CIMEROOT/$cimeroot/;
    $file =~ s/\$CASEROOT/$caseroot/;
    (-f "$file")  or  die "** Cannot find definition file $file ***\n";
    if ($print > 1) {print "General definitions: $file \n";}
    $cfg_ref->add_config_variables($file);
}

#------------------------------------------------------------------------------------------
# Set non-default values for the following cfg_ref elements (needed for the calls below)
#------------------------------------------------------------------------------------------
my $username = "$ENV{'USER'}"; #TODO - change ccsmuser to username
$cfg_ref->set('CCSMUSER'	  , "$username");
$cfg_ref->set('USER'	          , "$username");
$cfg_ref->set('CASEROOT'	  , "$caseroot");
$cfg_ref->set('CASETOOLS'         , "$caseroot/Tools");
$cfg_ref->set('CASEBUILD'         , "$caseroot/Buildconf");
$cfg_ref->set('CASE'		  , "$case");
$cfg_ref->set('CIMEROOT'	  , "$cimeroot");
$cfg_ref->set('UTILROOT'	  , "$cimeroot/scripts/Tools");
$cfg_ref->set('SRCROOT'		  , "$cimeroot/../");
$cfg_ref->set('CCSMROOT'	  , "$cimeroot/../"); #TODO - deprecate CCSMROOT = put out message

#------------------------------------------------------------------------------------------
# Determine the primary component AND file specifying supported compsets for the primary component
# Determine grid specs file
# Determine machines file
# Determine tests spec file if appropriate
#------------------------------------------------------------------------------------------
my $srcroot = $cfg_ref->get('SRCROOT');
my $parser = XML::LibXML->new( no_blanks => 1);
my $xml = $parser->parse_file("$definitions_file");

# obtain primary component (for now this is only CESM specific
my $primary_component;
if (! $opts{'compset'}) {
    die "ERROR: must set the -compset option to create_newcase \n";
}
$primary_component = ConfigCESM::getPrimaryComponent($compset);

# the value of the cfg_ref variable 'COMPSETS_SPEC_FILE' gives the full pathname of the
# file containing the possible out of the box compsets that can be used by create_newcase
my @compsets_files    = $xml->findnodes(".//entry[\@id=\"COMPSETS_SPEC_FILE\"]/values/value[\@primary_component=\"$primary_component\"]");
my $compsets_file = $compsets_files[0]->textContent();
$compsets_file =~ s/\$CIMEROOT/$cimeroot/;
$compsets_file =~ s/\$SRCROOT/$srcroot/;
_clean($compsets_file);
(-f "$compsets_file")  or  die "*** Cannot find compsets file $compsets_file ***\n";
$cfg_ref->set('COMPSETS_SPEC_FILE', "$compsets_file");

# determine tests spec file if appropriate
my @tests_files = $xml->findnodes(".//entry[\@id=\"TESTS_SPEC_FILE\"]/values/value[\@primary_component=\"$primary_component\"]");
my $tests_file = $tests_files[0]->textContent();
$tests_file =~ s/\$CIMEROOT/$cimeroot/;
$tests_file =~ s/\$SRCROOT/$srcroot/;
(-f "$tests_file")  or  die "** Cannot find tests file $tests_file ***\n";
$cfg_ref->set('TESTS_SPEC_FILE', "$tests_file");

# determine grid specs file
my $grids_file;
my $grids_dir;
if (defined $opts{'user_grid_dir'}){
    # Determine file specifying set of supported model grids
    $grids_dir = $opts{'user_grid_dir'};
    (-d $grids_dir)  or  die "** Cannot find user specified grid directory $grids_dir **\n";
    $grids_file = "$grids_dir/grids.xml";
    (-f "$grids_file")  or  die "** Cannot find user specified grids file $grids_file **\n";
} else {
    my @grids_default_dir = $xml->findnodes(".//entry[\@id=\"GRIDS_DIR\"]/default_value");
    $grids_dir = $grids_default_dir[0]->textContent();
    $grids_dir =~ s/\$CIMEROOT/$cimeroot/;
    $grids_dir =~ s/\$SRCROOT/$srcroot/;
    (-d "$grids_dir")  or  die "** Cannot find grids dir $grids_dir ***\n";
}    
$cfg_ref->set('GRIDS_DIR', "$grids_dir");

my $file = "$grids_dir" . '/' . "grids.xml";
$cfg_ref->set('GRIDS_SPEC_FILE', "$file");

my $file = "$grids_dir" . '/' . "grids_domains.xml";
$cfg_ref->set('GRIDS_DOMAINS_FILE', "$file");

my $file = "$grids_dir" . '/' . "grids_maps.xml";
$cfg_ref->set('GRIDS_MAPPINGS_FILE', "$file");

#------------------------------------------------------------------------------------------
# Options for listing (exit after listing) 
#------------------------------------------------------------------------------------------
if ($opts{'testlist'}) {
    my $tests_file = $cfg_ref->get('TESTS_SPEC_FILE');
    ConfigTests::listTests("$tests_file");
    exit;
}    

#------------------------------------------------------------------------------------------
# Determine compset longname, alias and support level 
# (compset_aliasname and support level not used here) TODO: remove redundancy
# Need to pass the value of $compsets_file set above as an argument
#------------------------------------------------------------------------------------------
my $compsets_file = $cfg_ref->get('COMPSETS_SPEC_FILE');
my ($compset_longname, $compset_aliasname, $support_level) = 
    ConfigCompsetGrid::getCompsetLongname($compsets_file, $compset, $opts{'user_compset'});  
$cfg_ref->set('COMPSET', "$compset_longname"); 

#------------------------------------------------------------------------------------------
# Determine compset components
#------------------------------------------------------------------------------------------
my @compset_components;
$compset_longname =~ m/(^\w\w\w\w\w)(.+)/; # remove the first date specified from the compset
my $components = $2;
my @elements = split /_/, $components;
foreach my $element (@elements) {
    my @element_components = split /%/, $element;
    my $component = lc $element_components[0];
    if ($component =~ m/\d+/) {
	$component =~ s/\d//g;
    }
    push (@compset_components, $component);
}

#------------------------------------------------------------------------------------------
# Determine variable definition files for each compset components 
# e.g. to obtain the directory containing the definitions_variable.xml file 
# for the atmospheric component you would use
#     my $file = $cfg_ref->get('CIMECONFIG_ATM_FILE');
# and if the atmopsheric component was datm $file would be set equal to 
#     $cimeroot/components/data_comps/datm/cimeconfig/definitions_component.xml
# all components will contain the file 
#      'definitions_component.xml
# that specify the xml variable definitions for that component 
# note that for CESM, the only primary components are
#     cam, clm, cice, cism, pop, drv, allactive
# so the directories for the primary components will contain the additional two files:
#     'compsets.xml' and 'pelayouts.xml'   
#------------------------------------------------------------------------------------------
my $xml = XML::LibXML->new( no_blanks => 1)->parse_file($definitions_file);
my @models = ('ATM', 'ICE', 'GLC', 'LND', 'OCN', 'ROF', 'WAV', 'DRV');  

my @files = $xml->findnodes(".//entry[\@id=\"CIMECONFIG_DRV_FILE\"]/values/value");
if (@files) {
    my $file = $files[0]->textContent();
    $file =~ s/\$CIMEROOT/$cimeroot/;
    (-f "$file")  or  die "** ERROR create_newcase: cannot find component definition file $file ***\n";
    $cfg_ref->set('CIMECONFIG_DRV_FILE', $file); 
}

# Sets CIMECONFIG_xxx_FILE - where xxx is one of ['ATM','ICE','GLC','LND','OCN','ROF','WAV']
foreach my $component (@compset_components) {
    foreach my $model (@models) {
	my $name = "CIMECONFIG_" . "$model" . "_FILE";
	my @files = $xml->findnodes(".//entry[\@id=\"$name\"]/values/value[\@comp=\"$component\"]");
	if (@files) {
	    my $file = $files[0]->textContent();
	    $file =~ s/\$CIMEROOT/$cimeroot/;
	    $file =~ s/\$SRCROOT/$srcroot/;
	    (-f "$file")  or  die "** ERROR create_newcase: cannot find component definition file $file ***\n";
	    $cfg_ref->set($name, $file); 
	    last;
	}
    }
}

# Sets BLD_xxx_DIR - where xxx is one of ['ATM','ICE','GLC','LND','OCN','ROF','WAV']
# The directory BLD_xxx_DIR contains the files xxx.buildnml and xxx.buildlib
foreach my $component (@compset_components) {
    foreach my $model (@models) {
	my $name = "BLD_" . "$model" . "_DIR";
	my @dirs = $xml->findnodes(".//entry[\@id=\"$name\"]/values/value[\@comp=\"$component\"]");
	if (@dirs) {
	    my $dir = $dirs[0]->textContent();
	    $dir =~ s/\$CIMEROOT/$cimeroot/;
	    $dir =~ s/\$SRCROOT/$srcroot/;
	    (-d "$dir")  or  die "** ERROR create_newcase: cannot find directory $dir ***\n";
	    $cfg_ref->set($name, $dir);
	    last;
	}
    }
}
my @dirs = $xml->findnodes(".//entry[\@id=\"BLD_DRV_DIR\"]/default_value");
if (@dirs) {
    my $dir = $dirs[0]->textContent();
    $dir =~ s/\$CIMEROOT/$cimeroot/;
    $dir =~ s/\$SRCROOT/$srcroot/;
    (-d "$dir")  or  die "** ERROR create_newcase: cannot find directory $dir ***\n";
    $cfg_ref->set('BLD_DRV_DIR', $dir);
} else {
    die "** ERROR create_newcase: could not find any nodes for BLD_DRV_DIR in $definitions_file*** \n"; 
}

#------------------------------------------------------------------------------------------
# Determine grid longname and alias 
# Need to pass the value of $grids_file set above as an argument
#------------------------------------------------------------------------------------------
my ($grid_longname, $grid_shortname, $grid_aliasname, $compset_match ) = ConfigCompsetGrid::getGridLongname($cfg_ref, $grid); 
$cfg_ref->set('GRID', "$grid_longname");

# Is the grid and compset consistent - TODO put this logic back in getGridLongname
if ($compset_match) {
    # if there is a compset attribute, does the compset longname 
    if ($compset_longname !~ /$compset_match/) {
	die " ERROR: no supported match for primary grid $grid and primary compset-match $compset_match \n";
    }
}

#------------------------------------------------------------------------------------------
# Set the cfg_ref variables for the specified compset and grid 
# (this will overwrite default values set in _definie_cfg_elements 
#------------------------------------------------------------------------------------------
ConfigCompsetGrid::setCompsetGrid($print, $cfg_ref);

#------------------------------------------------------------------------------------------
# Inform the user of the current support level for the compset they are attempting to run.
#------------------------------------------------------------------------------------------
my $testsforcase;
if ( $opts{'compset'} ) {
   my %case;
   $case{'compset'} = $opts{'compset'};
   $case{'grid'} = $opts{'res'};
   #   my $testlistobj = Testing::TestLists->new(scriptsdir => $cfgdir); TODO
   #   $testsforcase = $testlistobj->findTestsForCase(\%case); TODO
} else {
   $testsforcase = "WARNING!:: User compset names are NOT tested by the standard CESM process.\n" .
                   "           Thus you may likely find that this configuration will NOT work.\n" .
                   "           And you are completely on your own to figure out how to get it working.";
}
my $banner = '-' x 80;
# print "$banner\n";
if ( defined($support_level) ) {
   print "Compset and grid support levels for this case are:\n";
   print "$support_level\n";
}
print "$testsforcase\n";
# print "$banner\n";

#------------------------------------------------------------------------------------------
# Determine machines file specifying set of out-of-the box machines
# Then set the machine parameters, including compilers
#------------------------------------------------------------------------------------------
my $machines_file = ConfigMachine::setMachineFile($machine, $cimeroot, $machine, $definitions_file);
my $machines_dir = dirname($machines_file);
ConfigMachine::setMachineValues($machines_file, $machines_dir, $machine, $compiler, $print, $cfg_ref);
if ($print>=2) { print "Machine specifier: $machine.\n"; }

#------------------------------------------------------------------------------------------
# Set the testname parameters
#------------------------------------------------------------------------------------------
if (defined $opts{'testname'}) {
    $testname = $opts{'testname'};
    _set_test("$cfgdir/Testing/Testcases/config_tests.xml", $testname, $cfg_ref);
}

#------------------------------------------------------------------------------------------
# Set the input configure options if appropriate and also some additional $cfg_ref variables
#------------------------------------------------------------------------------------------
if (defined $opts{'confopts'}) {
    $confopts = $opts{'confopts'};
    _set_confopts($confopts, $cfg_ref);
}

#------------------------------------------------------------------------------------------
# Set the project id
# Check for optional project; if not given, see if we can find a project to use
#------------------------------------------------------------------------------------------
if ($opts{'project'}) {
   $project = $opts{'project'};
}
else {
   $project = ProjectTools::find_project();
}

if ($cfg_ref>get('PROJECT_REQUIRED') eq "TRUE") {
    ProjectTools::check_project_required_but_unset($project);
}
if (ProjectTools::set_project($project)) {
    $cfg_ref>set('PROJECT', $project);
} 

#------------------------------------------------------------------------------------------
# Set the case pe-layout
#------------------------------------------------------------------------------------------
ConfigPes::setPes($pecount, $compset_longname, $machine, $cimeroot, $primary_component, \%opts, $cfg_ref);

#------------------------------------------------------------------------------------------
# Set the mpi library and the repotag
#------------------------------------------------------------------------------------------
_set_mpi_library($mpilib, $cfg_ref);
_set_repotag($cimeroot, $cfg_ref);

#------------------------------------------------------------------------------------------
# Set the sharedlibroot for building shared CESM components
#------------------------------------------------------------------------------------------
if (defined $opts{'sharedlibroot'}) {
    $cfg_ref->set('SHAREDLIBROOT', $opts{'sharedlibroot'});
}

#------------------------------------------------------------------------------------------
# First create the caseroot directory tree and all caseroot required fiels
#------------------------------------------------------------------------------------------

# create the caseroot directory and necessary subdirectories
_create_caseroot($caseroot, $cimeroot, $definitions_file, $cfg_ref);

# Copy the user_mods_dir files in and apply them
if ( defined($user_mods_dir) ) {
   my $is_test = 0;
   if ($testname) {$is_test = 1;}
   UserModsTools::apply_mods($user_mods_dir, $caseroot, $print, $is_test);
}

#------------------------------------------------------------------------------------------
# finish
#------------------------------------------------------------------------------------------
if ($print) {print "Successfully created the case for $machine \n";}
if ($print>=2) { print "create_xml done.\n"; }
exit 0;

#-----------------------------------------------------------------------------------------------
#                               Private routines
#-----------------------------------------------------------------------------------------------
sub _check_input_options
{

    if (!$opts{'testlist'}) {
	# Check for manditory case input
	if ($opts{'case'}) {
	    $case = $opts{'case'};
	} else {
	    die "ERROR: create_newcase must include the input argument, -case \n";
	}
	if (-d $case) {
	    die "Case directory $case already exists \n";
	}
	mkpath($case); 
	$caseroot = abs_path("$case");

	my @dirs = split "/", $caseroot, -1;  # The -1 prevents split from stripping trailing nulls
	my $num = scalar @dirs;
	$case = $dirs[$num-1];

	# Check for manditory compset input
	if ($opts{'compset'}) {
	    $compset = $opts{'compset'};
	} else {
	    if (!$opts{'user_compset'}) {
		die "ERROR: create_newcase must include the input argument, -compset or user_compset\n";
	    }
	}
	# Check for mandatory grid input
	if ($opts{'res'}) {
	    $grid = $opts{'res'};
	} else {
	    die "ERROR: create_newcase must include the input argument, -res\n";
	}
	# Check for manditory machine input
	if ($opts{'mach'}) {
	    $machine = $opts{'mach'};
	} else {
	    die "ERROR: create_newcase must include the input argument, -mach \n";
	}
	# Check if machine compiler option is given
	if ($opts{'compiler'}) {
	    $compiler = $opts{'compiler'};
	}
	# Check if machine mpilib option is given
	$mpilib = 'unset';
	if ($opts{'mpilib'}) {
	    $mpilib = $opts{'mpilib'};
	}
	# Check for pecount setting
	$pecount = 'M';
	if ($opts{'pecount'}) {
	    $pecount = $opts{'pecount'};
	}
	# Check for xmlmode setting
	$xmlmode = 'normal';
	if ($opts{'xmlmode'}) {
	    $xmlmode = $opts{'xmlmode'};
	}
    }
}

#-------------------------------------------------------------------------------
sub _define_cfg_elements
{
    my ($cimeroot, $opts_ref, $primary_component, $cfg_ref) = @_;
}

#-------------------------------------------------------------------------------
sub _set_confopts
{
    # Print all currently supported valid grids

    my ($coptions, $cfg_ref) = @_;

    print "  confopts = $coptions\n";
    if ($coptions =~ "_D" || $coptions =~ "_ED") {
	$cfg_ref->set('DEBUG', "TRUE");
	print "    confopts DEBUG ON \n";
    }
    if ($coptions =~ "_E" || $coptions =~ "_DE") {
	$cfg_ref->set('USE_ESMF_LIB', "TRUE");
	$cfg_ref->set('COMP_INTERFACE', "ESMF");
	print "    confopts COMP_INTERFACE ESMF set \n";
    }

    if ($coptions =~ "_P") {
	my $popt = $coptions;
	$popt =~ s/.*_P([A-Za-z0-9]*)_?.*/$1/;
	$pecount = $popt;
	print "    confopts pecount set to $pecount \n";
    }
    if ($coptions =~ "_M") {
	my $mopt = $coptions;
	$mopt =~ s/.*_M([A-Za-z0-9\-]*)_?.*/$1/;
	$mpilib = $mopt;
	print "    mpilib set to $mpilib \n";
    }
    if ($coptions =~ "_L") {
	my $lopt = $coptions;
	$lopt =~ s/.*_L([A-Za-z0-9]*)_?.*/$1/;
	my $loptc = substr($lopt,0,1);
	my $lopti = substr($lopt,1);
	my $lopts = 'unknown';
	if ($loptc =~ "y") {$lopts = 'nyears'}
	if ($loptc =~ "m") {$lopts = 'nmonths'}
	if ($loptc =~ "d") {$lopts = 'ndays'}
	if ($loptc =~ "h") {$lopts = 'nhours'}
	if ($loptc =~ "s") {$lopts = 'nseconds'}
	if ($loptc =~ "n") {$lopts = 'nsteps'}
	if ($lopts =~ "unknown") {
	    print "$0 _L confopts run length undefined, only y m d h s n allowed\n\n";
	    exit -1;
	}
	$cfg_ref->set('STOP_OPTION', $lopts);
	$cfg_ref->set('STOP_N', $lopti);
	print "    confopts run length set to $lopt . $lopts . $lopti \n";
    }
    if ($coptions =~ "_N") {
	my $nopt = $coptions;
	$nopt =~ s/.*_N([0-9]*)_?.*/$1/;
	$cfg_ref->set('NINST_ATM', $nopt);
	$cfg_ref->set('NINST_LND', $nopt);
	$cfg_ref->set('NINST_OCN', $nopt);
	$cfg_ref->set('NINST_ICE', $nopt);
	$cfg_ref->set('NINST_GLC', $nopt);
	$cfg_ref->set('NINST_ROF', $nopt);
	$cfg_ref->set('NINST_WAV', $nopt);
	print "    confopts instances set to $nopt \n";
    }
    if ($coptions =~ "_CG") {
	$cfg_ref->set('CALENDAR', "GREGORIAN");
	print "    confopts CALENDAR set to GREGORIAN \n";
    }
    if ($coptions =~ "_AOA") {
	$cfg_ref->set('AOFLUX_GRID', "atm");
	print "    confopts AOFLUX_GRID set to atm \n";
    }
    if ($coptions =~ "_AOE") {
	$cfg_ref->set('AOFLUX_GRID', "exch");
	print "    confopts AOFLUX_GRID set to exch \n";
    }
}

#-------------------------------------------------------------------------------
sub _set_mpi_library
{
    # set the mpi library, $mpilib
    # $mpilib can be set by -mpilib, confopts, or automatically
    # precedent is confopts, mpilib, automatic, default

    my ($mpilib, $cfg_ref) = @_;

    my $mpilibs = $cfg_ref->get('MPILIBS');
    my @mpilibs = split ",", $mpilibs, -1;

    if ($mpilib =~ 'unset') 
    {
	if ($cfg_ref->get('NTASKS_ATM') == 1 && $cfg_ref->get('NTASKS_LND') == 1 &&
	    $cfg_ref->get('NTASKS_OCN') == 1 && $cfg_ref->get('NTASKS_ICE') == 1 &&
	    $cfg_ref->get('NTASKS_ROF') == 1 && $cfg_ref->get('NTASKS_GLC') == 1 &&
	    $cfg_ref->get('NTASKS_WAV') == 1 && $cfg_ref->get('NTASKS_CPL') == 1) 
	{ 
	    $mpilib = "mpi-serial"; 
	}
    }
    if ( $mpilib =~ 'default' || $mpilib =~ m/^\s*$/ ) {
	$mpilib = $mpilibs[0];
    }
    if (! ($mpilib =~ 'unset')) {
	my $found = 0;
	foreach my $mpi (@mpilibs) {
	    if ($mpilib eq $mpi) {
		$found = 1;
	}
	}
	if (!$found) {
	    $sysmod = "rm -rf $caseroot";
	    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
	    die "ERROR: mpilib setting of $mpilib does not match supported values of $mpilibs \n";
	}
    } else {
	if ($machine =~ /userdefined/){
	    $mpilib = "USERDEFINED_required_build";
	}else{
	    $mpilib = $mpilibs[0];
	}
    }    
    $cfg_ref->set('MPILIB', "$mpilib");
    if ($print>=2) { print "Machine mpilib specifier: $mpilib.\n"; }
}

#-------------------------------------------------------------------------------
sub _set_repotag 
{
    my ($cimeroot, $cfg_ref) = @_; 

    my $repotag;
    if (-f "$cimeroot/ChangeLog") { 
	$repotag =`cat $cimeroot/ChangeLog | grep 'Tag name:' | head -1`;
    }
    my @repotag = split(/ /,$repotag); 
    $repotag = $repotag[2]; 
    chomp($repotag);
    $cfg_ref->set('CCSM_REPOTAG', $repotag);
}

#-------------------------------------------------------------------------------
sub _create_caseroot
{
    # Create caseroot directory and all necessary sub directories
    my ($caseroot, $cimeroot, $definitions_file, $cfg_ref) = @_;

    print "Creating $caseroot \n";
    mkdir ("$caseroot");
    chdir ("$caseroot");

    my $scriptsroot = "$cimeroot/scripts";

    # Create relevant directories in $caseroot
    my @newdirs = qw(. SourceMods LockedFiles Buildconf Tools);
    foreach my $newdir ( @newdirs ) {
	mkpath($newdir); 
    }

    # Open a new README.case file in $caseroot
    my $file = "$caseroot/README.case";
    my $fh = IO::File->new($file, '>' ) or die "can't open file: $file\n";
    print $fh "$commandline\n\n\n";
    $fh->close;

    # print README/disclaimer file in scripts dir
    $sysmod = "cp $scriptsroot/README $caseroot/README.science_support";
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";

    _create_caseroot_sourcemods($caseroot, $cimeroot, $cfg_ref);  
    _create_caseroot_tools ($caseroot, $scriptsroot);
    _create_caseroot_buildconf($caseroot, $cimeroot, $cfg_ref);  
    _create_caseroot_files($case, $caseroot, $cimeroot, $scriptsroot, $machines_dir, $machine, $compiler, $definitions_file, $print, $cfg_ref);
}

#-------------------------------------------------------------------------------
sub _create_caseroot_tools
{
    # Copy relevant files into $caseroot
    my ($caseroot, $scriptsroot) = @_;
    
    $sysmod;

    my @files = (
	"$scriptsroot/Tools/cesm_setup", 
	"$scriptsroot/Tools/testcase_setup", 
	"$scriptsroot/Tools/check_input_data", 
	"$scriptsroot/Tools/archive_metadata.sh", 
	"$scriptsroot/Tools/check_case", 
	"$scriptsroot/Tools/create_production_test", 
	"$scriptsroot/Tools/xmlchange",
	"$scriptsroot/Tools/xmlquery",
	"$scriptsroot/Tools/st_archive", 
	"$scriptsroot/Tools/README.post_process", 
	); 
    foreach my $file (@files) {
	$sysmod = "cp -p $file $caseroot"; 
	system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    }
    $sysmod = "chmod u+w $caseroot/create_production_test";
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    
    my $mkbatch = "$ENV{'HOME'}/.cime/mkbatch.$machine";
    if (! -f "$mkbatch") {
	$mkbatch = "$machines_dir/mkbatch.$machine";
    } else {
	print "\nUsing UNSUPPORTED userdefined mkbatch script: \"~/.cime/mkbatch.$machine\"\n";
    }
    
    # Copy relevant files into $caseroot/Tools/
    @files = ("$scriptsroot/cimeconfig/archive.xml",
	      "$scriptsroot/cimeconfig/archive.xsd",
	      "$scriptsroot/Tools/cesm_buildnml", 
	      "$scriptsroot/Tools/cesm_prestage", 
	      "$scriptsroot/Tools/cesm_prerun_setup", 
	      "$scriptsroot/Tools/cesm_postrun_setup", 
	      "$scriptsroot/Tools/check_lockedfiles", 
	      "$scriptsroot/Tools/lt_archive.sh", 
	      "$scriptsroot/Tools/st_archive", 
	      "$scriptsroot/Tools/getTiming", 
	      "$scriptsroot/Tools/SetupTools.pm",
	      "$scriptsroot/Tools/ConfigCase.pm",
	      "$scriptsroot/Tools/compare_namelists.pl",
	      "$machines_dir/ccsm_getenv", 
	      "$machines_dir/taskmaker.pl", 
	      "$machines_dir/Makefile",
	      "$machines_dir/mkSrcfiles", 
	      "$machines_dir/mkDepends", 
	      "$mkbatch");
    
    foreach my $file (@files) {
	$sysmod = "cp -p $file $caseroot/Tools/. "; 
	system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    }
}

#-------------------------------------------------------------------------------
sub _create_caseroot_files
{
    my ($case, $caseroot, $cimeroot, $scriptsroot, $machines_dir, $machine, 
	$compiler, $definitions_file, $print, $cfg_ref) = @_;

    my $mkbatch_file = "$machines_dir/mkbatch.$machine";
    (-f "$mkbatch_file")  or  die "** Cannot find mkbatch file $mkbatch_file ***\n";

    $sysmod;

    # Create $case.build
    $sysmod = "cp $scriptsroot/Tools/cesm_build.csh  $caseroot/$case.build";
    system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
    $sysmod = "chmod 755 $caseroot/$case.build";
    system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}

    # Create $caseroot/Buildconf/cesm_build.pl
    $sysmod = "cp $scriptsroot/Tools/cesm_build.pl  $caseroot/Buildconf/cesm_build.pl";
    system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}

    $sysmod = "chmod 755 $caseroot/Buildconf/cesm_build.pl";
    system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
    
    # Create $case.clean_build
    $sysmod = "cp $scriptsroot/Tools/cesm_clean_build $caseroot/$case.clean_build"; 
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    
    # Create $case.submit
    $sysmod = "cp  $scriptsroot/Tools/cesm_submit $caseroot/$case.submit"; 
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";

    # Create $case.l_archive
    $sysmod = "env CCSMUSER=$username CASE=$case CASEROOT=$caseroot PROJECT=$project env PHASE=set_larch $mkbatch_file";
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";

    # Create $caseroot preview_namelist file
    my $file = "${caseroot}/preview_namelists"; 
    $sysmod = "cp  $scriptsroot/Tools/preview_namelists $file"; 
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";

    $sysmod = "chmod 755 $file";
    system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}

    if (-e "$machines_dir/env_mach_specific.$machine" ) {
	$sysmod = "cp $machines_dir/env_mach_specific.$machine $caseroot/env_mach_specific";
	system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    } else {
	$sysmod = "touch $caseroot/env_mach_specific";
	system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    }

    if ( -e "$machines_dir/Depends.$machine" ) {
	$sysmod = "cp $machines_dir/Depends.$machine $caseroot/";
	system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    }
    if ( -e "$machines_dir/Depends.$compiler" ) {
	$sysmod = "cp $machines_dir/Depends.$compiler $caseroot/";
	system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    }

    # Create env_case.xml
    $cfg_ref->write_file("$caseroot/env_case.xml", "$definitions_file", $caseroot, $cimeroot );
    if ($print) {print "Created $caseroot/env_case.xml \n";}

    # Create env_mach_pes.xml.xml
    $cfg_ref->write_file("$caseroot/env_mach_pes.xml", "$definitions_file", $caseroot, $cimeroot );  
    if ($print) {print "Created $caseroot/env_mach_pes.xml \n";}

    # Create env_build.xml
    $cfg_ref->write_file("$caseroot/env_build.xml", "$definitions_file", $caseroot, $cimeroot );
    if ($print) {print "Created $caseroot/env_build.xml \n";}

    # Create env_run.xml
    $cfg_ref->write_file("$caseroot/env_run.xml", "$definitions_file", $caseroot, $cimeroot );
    if ($print) {print "Created $caseroot/env_run.xml \n";}

    # Create env_archive.xml
    $cfg_ref->write_file("$caseroot/env_archive.xml", "$definitions_file", $caseroot, , $cimeroot, 
			 "$cimeroot/scripts/cimeconfig/archive.xml");
    if ($print) {print "Created $caseroot/env_archive.xml \n";}

    # copy env_case.xml in to locked files
    $sysmod = "cp $caseroot/env_case.xml $caseroot/LockedFiles/env_case.xml.locked"; 
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    if ($print) {print "Locking file $caseroot/env_case.xml \n";}

    # also create the CaseStatus file in $caseroot
    my $file = "$caseroot/CaseStatus";
    my $fh = IO::File->new($file, '>' ) or die "can't open file: $file\n";
    my $time = time;
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
    $year = 1900+$year;
    $mon = 1+$mon;
    print $fh "$commandline\n";
    printf ($fh "case created %04u-%02u-%02u %02u:%02u:%02u\n",$year,$mon,$mday,$hour,$min,$sec);
}

#-------------------------------------------------------------------------------
sub _create_caseroot_buildconf
{
    my ($caseroot, $cimeroot, $cfg_ref) = @_;  

    my $dir_atm  = $cfg_ref->get("BLD_ATM_DIR"); 
    my $dir_lnd  = $cfg_ref->get("BLD_LND_DIR"); 
    my $dir_ocn  = $cfg_ref->get("BLD_OCN_DIR"); 
    my $dir_ice  = $cfg_ref->get("BLD_ICE_DIR"); 
    my $dir_glc  = $cfg_ref->get("BLD_GLC_DIR"); 
    my $dir_rof  = $cfg_ref->get("BLD_ROF_DIR"); 
    my $dir_wav  = $cfg_ref->get("BLD_WAV_DIR");

    my $sysmod;
    my $buildconf  = "$caseroot/Buildconf";
    my @bld_dirs = ($dir_atm, $dir_lnd, $dir_ocn, $dir_ice, $dir_glc, $dir_rof, $dir_wav); 
    foreach my $bld_dir (@bld_dirs) {
	$sysmod = "cp -p $bld_dir/*.buildlib $buildconf/.";
	system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";

	$sysmod = "cp -p $bld_dir/*.buildnml $buildconf/.";
	system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
	
	# TODO: the following is CESM specific and should be move to the ConfigCESM.pm module
	if ($bld_dir =~ /cism/) {
	    $sysmod = "cp -p $bld_dir/cism.template $buildconf/.";
	    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
	}
	if ($bld_dir =~ /cice/) {
	    $sysmod = "cp $bld_dir/generate_cice_decomp.pl $buildconf/."; 
	    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
	}
	if ($bld_dir =~ /pop/) {
	    $sysmod = "cp $bld_dir/generate_pop_decomp.pl $buildconf/."; 
	    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
	} 
    }

    # copy cpl.buildnml and cpl.buildexe into Buildconf/
    $sysmod = "cp -p $cimeroot/driver_cpl/bld/cpl.buildnml $buildconf/.";
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";

    $sysmod = "cp -p $cimeroot/driver_cpl/bld/model.buildexe $buildconf/.";
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";

    # copy external libraries buildlib.xxx into Buildconf/
    # ---TODO: this will need to be generalized when csm_share is split up

    foreach my $lib ("gptl", "mct", "csm_share", "pio") {
	$sysmod = "cp ${machines_dir}/buildlib.${lib} $buildconf/.";
	system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    }
}


#-------------------------------------------------------------------------------
sub _create_caseroot_sourcemods
{
    my ($caseroot, $cimeroot, $cfg_ref) = @_;  

    my $comps_atm  = $cfg_ref->get("COMP_ATM"); 
    my $comps_lnd  = $cfg_ref->get("COMP_LND"); 
    my $comps_ocn  = $cfg_ref->get("COMP_OCN"); 
    my $comps_ice  = $cfg_ref->get("COMP_ICE"); 
    my $comps_glc  = $cfg_ref->get("COMP_GLC"); 
    my $comps_rof  = $cfg_ref->get("COMP_ROF"); 
    my $comps_wav  = $cfg_ref->get("COMP_WAV");
    my @comps  = ($comps_atm, $comps_lnd, $comps_ocn, $comps_ice, $comps_glc, $comps_rof, $comps_wav); 

    # Create sourcemods
    my $moddir = "$caseroot/SourceMods";
    foreach my $comp (@comps)  {
	mkpath("$moddir/src.$comp"); 
	# ---TODO: this is CESM specific given that we are referencing cism explitly
	# this logic should be moved to ConfigCESM.pm
	if ($comp eq 'cism') {
	    mkpath("$moddir/src.$comp/glimmer-cism");
	    open(README, ">", "$moddir/src.$comp/README") or
		die "cannot open > $moddir/src.$comp/README: $!";
	    print README
		"Put source mods for the glimmer-cism library in the glimmer-cism subdirectory.\n",
		"This includes any files that are in the glimmer-cism subdirectory of $cimeroot/../components/cism.\n\n",
		"Anything else (e.g., mods to source_glc or drivers) goes in this directory, NOT in glimmer-cism/.\n";
	    close(README);
	}
    }
    mkpath("$caseroot/SourceMods/src.share"); 
    mkpath("$caseroot/SourceMods/src.drv"); 
}

#-------------------------------------------------------------------------------
sub _set_test
{
    # Set the parameters for the specified testname.  The
    # parameters are read from an input file, and if no testname matches are
    # found then issue error message.
    # This routine uses the configuration defined at the package level ($cfg_ref).

    my ($test_file, $testname, $cfg_ref) = @_;

    my $parser = XML::LibXML->new( no_blanks => 1);
    my $xml = $parser->parse_file($test_file);
    my @nodes = $xml->findnodes(".//test[\@NAME=\"$testname\"]/*");
    if (@nodes) {
	foreach my $node (@nodes) {
	    my $id = $node->nodeName();
	    my $value = $node->textContent();
	    $cfg_ref->set($id, $value);
	}
    } else {
	print "_set_test: no match for test $testname - possible testnames are \n";
	@nodes = $xml->findnodes(".//test");
	foreach my $node (@nodes) {
	    my $name = $node->getAttribute('NAME');
	    my @child_nodes = $node->findnodes('./DESC');
	    my $desc = $child_nodes[0]->textContent();
	    print " $name ($desc) \n" ;
	}
	die "_set_test: exiting\n"; 
    }
}

#-------------------------------------------------------------------------------
sub _clean
{
    my ($name) = @_;
    
    $name =~ s/^\s+//; # strip any leading whitespace 
    $name =~ s/\s+$//; # strip any trailing whitespace
    return ($name);
}


